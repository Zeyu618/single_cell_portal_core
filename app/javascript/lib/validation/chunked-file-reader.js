import { DEFAULT_CHUNK_SIZE, readFileBytes } from './io'

const newlineRegex = /\r?\n/

/** reads a file as lines in a set of 'chunks'  Each chunk is determined by chunkSize
 * This class handles tracking lines that span chunk boundaries -- such lines will be excluded
 * from the chunk they start in, and included in full in the subsequent chunk.
 * Note that this means some chunks may be "empty" if there are lines that span entire chunks.
 *
 * So e.g. if an expression file has a 4.5MB long header row listing the cells, the first four calls
 * to 'getNextChunk' will return an empty array, and then the fifth call will return the full line
 * this behavior is so that the number of chunks available to be returned is dependent only on file size,
 * rather than newline parsing
 */
export class ChunkedLineReader {
  /** create a new chunk reader */
  constructor(file, chunkSize=DEFAULT_CHUNK_SIZE) {
    this.file = file
    this.chunkIndex = 0
    this.chunkSize = chunkSize
    this.previousFragment = null
  }

  /** get the number of chunks available */
  numChunks() {
    return Math.ceil(this.file.size / this.chunkSize)
  }

  /** return the next chunk as an array of lines */
  async getNextChunk() {
    if (this.chunkIndex >= this.numChunks()) {
      return false
    }
    const startByte = this.chunkIndex * this.chunkSize
    const isLastChunk = startByte + this.chunkSize >= this.file.size
    const chunkString = await readFileBytes(this.file, startByte, this.chunkSize)

    const lines = chunkString.split(/\r?\n/)

    if (this.previousFragment) {
      if (lines[0][0] === '\n') {
        // the current chunk started with a newline, so the previousFragment was in fact an intact line
        lines.unshift(this.previousFragment)
      } else {
        // append the fragment to the beginning of the first line
        lines[0] = this.previousFragment + lines[0]
      }
    }
    this.previousFragment = null
    this.chunkIndex++
    if (!isLastChunk || chunkString.slice(-1).match(newlineRegex)) {
      // As long as this isn't a last chunk of a file that isn't newline terminated,
      // omit the last line, and save it to append to the next chunk (if there is one).
      // This takes care of both handling fragments, and removing the empty line generated by
      // .split() if the chunk is newline terminated
      this.previousFragment = lines.pop()
    }
    return lines
  }
}
